#+TITLE: Об использовании языка C++ для обучения программированию
#+AUTHOR: Друан Филипп Сергеевич
#+LANGUAGE: ru

#+LATEX_CLASS:  article
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \hypersetup{colorlinks=true}

* Преамбула
Основной посыл моей статьи состоит в том, что C++ не следует изучать в качестве первого языка программирования, особенно студентам, для которых программирование не является основным предметом. Гораздо лучше будет дать им освоить фундаментальные навыки программиста на примере языка, который предназначен для обучения новичков. Это позволит сделать процесс обучения более осознанным, постепенным, спокойным, глубоким. C++ привносит в обучение дополнительную сложность, так-как это промышленный язык, предназначенный для профессионалов. Его изучение стоит отложить до второго курса. Достойная альтернатива - язык Racket.
Цель статьи - скорее поднять вопросы, чем дать ответы, и конечно же, не очернить C++. В статье приведены предполагаемые критерии того, каким должен быть первый язык, а так же проведены примеры, почему C++ не соответствует эти критериям.
* Вводные положения
** Цель вводного курса программирования
Думаю, вы согласитесь, что основная цель вводного курса программирования - *научиться думать* как программист, разделять задачу на части, строить грамотные абстракции, освоить базовые средства построения программ: условия, циклы, функции. Выучить *конкретный язык* - это далеко *не первая задача*. Языки *появляются и предаются забвению*, а правильное мышление *остаётся* с программистом на всю жизнь.

И не только с программистом. В любой сфере деятельности программирование оставит свой след, поможет правильно мыслить.

Поэтому, *крайне важно* с самого начала заложить *крепкое основание*. Студент должен *освоить фундаментальные концепции* программирования максимально *чётко и ясно*, а не интуитивно (в плохом смысле) и размыто.

Далеко *не все*, кто изучает программирование станут *профессиональными программистами*. Но научиться чётко и ясно мыслить нужно всем. Плюс, навыки программирования могут помочь в чисто практических вещах, таких как расчёты, моделирование и так далее.

Правильный язык играет в этом далеко не последнюю роль, хотя научится можно на примере любого языка, если захотеть.

** Важна доступность для среднего студента
Если человек его любит программирование, он всё сделает сам, будет сидеть ночами у компьютера, читать книги. Но не все такие. Есть и *менее мотивированные* студенты. Возможно, они даже *никогда* толком не программировали (в школе дают очень мало практики). Возможно, у них дома даже *нет ПК, только смартфон*. Особенно это касается тех, кто учится на совершенно других факультетах, например, инженеров, физиков, химиков и так далее. У студентов *очень большая нагрузка*! Вероятно, они даже не сильно хотят учится программированию.

Кроме того, полагаю, что очень у многих студентов серьёзные проблемы с вниманием. Может быть, они даже имеют органический характер. Возможно, это следствие воспитания и образа жизни. Сейчас у людей очень много отвлекающих факторов.

По этому, очень важно *сделать процесс освоения* программирования как можно более *лёгким и радостным*. Конечно, в этом деле есть своя, *внутренняя сложность*, от которой *никуда не деться*, это сложность самого ремесла. Но есть и *привнесённая сложность*, которая появляется из-за *несовершенства* подходов и учебной программы. Её нужно *гнать метлой*. Она не имеет никакого права на существование.

** Очевидные для профессионала вещи не очевидны для новичка
Когда ты давно изучаешь какую-то тему, когда ты в неё погружён, есть опасность забыть, что эта тема требует усилий и времени, чтобы её понять. За этим можно упустить некоторые детали, шаги в рассуждениях, и вся цепочка развалится.

** Сложные вещи нужно разделять, а не смешивать
Сложность - это то, что мешает больше всего. Работа программиста во многом состоит в том, чтобы бороться со сложностью. Я уже сказал про внутреннюю и привнесённую сложность.

Сложность пугает, когда сталкиваешься с ней, хочется заняться чем-то другим.

Самый главный способ борьбы со сложностью - это разделение сущностей на части. В преподавании этот принцип тоже применим.

Если преподавать всё сразу, смешивать высокий и низкий уровень абстракции, параллельно изучать сложный инструментарий, да ещё и на одном занятии, у студентов будет каша в голове. Это всё очень сложные вещи. Но если разнести всё это во времени, дать освоиться в самых основах, то человек легко освоит материал. Позднее, мы разберём этот вопрос подробнее.

По этому, очень важно точно понимать чему мы хотим научить студента в данный момент времени.
** Нужно расширять кругозор
Кирилл Мокевнин в своей статье "Монокультура в программировании" пишет:
#+begin_quote
Я считаю крайне важным, чтобы человек, который учится программировать, делал это не на том языке, на котором он будет (планирует) писать код за деньги. Причем не менее важно то, что язык должен быть совсем другой. Если вы писали в университете на c#, а на работе пишите на java, то для вас мало что поменялось. Переход с динамического на статический язык (или наоборот) дает гораздо больше для общего развития, еще лучше, если этот язык из другой парадигмы.
#+end_quote


* Каким должен быть первый язык?
На мой взгляд, первый язык должен максимально помогать в изучении концепций, и как можно меньше мешать.
На практике, мне представляются важными следующие критерии:

** Концептуальная стройность

В книге "Структура и интерпретация компьютерных программа" (SICP) Абельсона и Сассмана указываются три основных компонента любого языка:
 1) Базовые элементы, из которых строятся более сложные сущности - например, встроенные функции и структуры данных.
 2) Средства комбинирования этих простых элементов в более сложные конструкции. Например, правила построения выражений, операторы
    управления потоком и так далее.
 3) Средства абстрагирования, которые позволяют работать со сложными объектами так же, как мы работаем с простыми. К таковым относятся
    объявление функций, классов и тому подобные вещи.

Очень важно, чтобы все эти элементы хорошо согласовались между собой, дополняли друг-друга и уж тем более не противоречили. Тогда у
студента гораздо легче сложится целостная картина.

Должна быть возможность взять некую концепцию языка, и рассмотреть её максимально обособленно. Поиграть с ней, разобраться, что она из себя
представляет, так, чтобы остальные концепции не мешались под ногами.

Например, в SICP вся первая глава (примерно 85 страниц) посвящена одним только функциям. Они рассматриваются очень подробно, разбирается, что с ними можно делать. Составные типы в этой главе не рассматриваются вообще. Во второй главе рассматриваются способы построения абстракций при помощи составных структур данных. В третьей главе вводится присваивание, и этого оказывается достаточно, чтобы использовать ООП. Чтобы не быть голословным, приведу пример написания кода в объектно-ориенторванном стиле на языке, в котором этой парадигмы изначально нет:

#+begin_src scheme
  #lang racket

  ;Объявляем конструктор объекта door
  (define (make-door key)
    (define reference-key key)
    (define opened? #f)

    (define (open key)
      (if opened?
          (println "Уже открыто!")
          (if (equal? reference-key
                      key)
              (set! opened? #t)
              (println "Ключ не подходит к замку!"))))

    (define (close key)
      (if (not opened?)
          (print "Уже закрыто!")
          (if (equal? reference-key
                      key)
              (set! opened? #f)
              (println "Ключ не подходит к замку!"))))

    (define (pass)
      (if opened?
          (println "Захди, садись!")
          (println "Кто стучится в дверь мою?")))

    (define (dispatch method-name)
      (case method-name
        [(open)  open]
        [(close) close]
        [(pass)  pass]
        [(opened?) opened?]))

    door)

  ; Используем его

  (define my-door (make-door 123))

  ((my-door 'pass))
  ; => Кто стучится в дверь мою?

  ((my-door 'open) 45)
  ; => Ключ не подходит к замку!

  ((my-door 'open) 123)

  ((my-door 'pass))
  ; => Заходи, садись!
#+end_src

Да, приходится писать многое вручную, но зато у студента появляется понимание того, что ООП - это не какая-то магия, а подход, который можно реализовать самому, причём разными способами [fn:: Замечу, что это подобный пример помещён в SICP на страницу 239, так что он для тех, кто уже освоился в основах Scheme или Racket (В эих языках пример отличается только наличием первой строчки)]. А добавить синтаксический сахар можно просто написав несколько макросов[fn:: Думаю, студентам не помешает изучить макросы, но в конце курса]

** Обозримость и познаваемость
Так-как нам нужно твёрдо закрепить основы, знать их все, то мне кажется полезным, если первый язык для студента станет понятен целиком, так, что не останется никаких "заклинаний", которые делают что-то, что он не понимает. Особенно хорошо, если студент сможет, при желании, сам написать интерпретатор или компилятор подмножества этого языка, которое
бы включало в себя все основные его концепции.[fn:: Такой подход нашёл своё применение на практике. В той же SICP одна из глав посвящена разработке интерпретатора Лиспа. Знаменитый
Профессор Никлаус Вирт так же считал полезным для студента написать простенький компилятор. К счастью, это не трудно, зато позволяет: а. Понять, как устроен язык программирования б. Попрактиковаться в ассемблере в. Сделать всё это в одном интересном проекте.]
Для программиста очень вредно относиться к языку и к компьютеру, как к чему-то волшебному, что нельзя понять.

** Постепенное увеличение сложности
Вспомним, что сложные вещи следует разделять, а не смешивать. Это проявляется и в первом языке программирования. Нужно хорошо *освоиться* в самых *базовых вещах*, знать их как свои пять пальцев, и только *потом переходить* к изучению более сложных. Если сразу *завалить* студента самыми разными концепциями, он может в них *запутаться*, воспринимать их как какие-то волшебные заклинания, которые что-то делают, но не понятно что.

*Когнитивная сложность задачи* - это одна из причин того, что студент может начать *отлынивать*. На своём опыте я это испытал. Если ты всё понимаешь, учится легко и приятно. Если нет - это мука. И это учитывая то, что у студента куча других предметов, особенно у физиков и механиков.

При этом, конечно, может не помешать сделать общий *обзор* языка, чтобы студенты как бы взглянули на него с высоты, и видели общую картину. Обзор, я полагаю, должен быть достаточно простым и понятным, чтобы язык стал для студентов знакомым, но не показался чем-то заумным.

Кроме того, полагаю, что это может *помочь* и самому *преподавателю*. Он сможет сосредаточиться на самом *главном*, ему не придётся переключаться с одной темы на другую, *подтягивать* студентов, которые плавают в материале из за того, что им пришлось учить сразу *кучу всего*, отлынивают и в результате впустую тратят время. Если студентам всё ясно, они будут слушать гораздо внимательнее.

Как пример, можно привести тот же SICP и Scheme, но я уже расписал, как там выстроено обучение, так что можно не повторяться.

** Хорошие практики программирования
Язык должен с самого начала приучать программиста писать *хороший код*.

Какие это практики? Мне приходят на ум такие:
  1) Правильное именование.
  2) Разделение кода на части.
  3) Хорошее, красивое оформление кода.


Одной из главных хороших практик, к которым нужно сразу приучаться, это сведение к *минимуму изменяемого состояния и побочных эффектов*, так как у них есть следующие недостатки:
 1) Зависимость от порядка вычисления, нужно определить, какую переменную менять первой, и тому подобное
 2) Необходимо контролировать побочные эффекты
 3) Невозможность использования подстановочной модели вычислений

Конечно,часто они бывают полезны, но его лучше избегать. Побочных эффектов должно быть как можно меньше, они должны быть в строго определённых местах[fn:: Я не предлагаю всё писать на Haskell! Но взять из функционального подхода всё, что он может дать хорошего обязательно нужно.].

Существует такое понятие, как структурный дизайн. Его суть в следующем:
Мы разделяем код на четыре части:
  1) Отвечает за ввод данных
  2) Отвечает за вывод данных
  3) Обрабатывает данные, осуществляет их трансформацию.
  4) Управляет всем остальным.
Эти части не смешиваются. Ввод и вывод мы оставляем по краям, а обработка приближается к чистой функции (а то и становится ей).
Мне такой подход кажется достаточно хорошим. В нём обработка данных отделяется от их чтения и записи.

Очень многие современные языки программирования вбирают в себя возможности из функциональных языков, так что с ними нужно уметь работать.
Виталий Брагилевский сравнивал функциональные языки с лабораторией, в которой изобретаются новые интересные вещи, часть из которых переходит в промышленные языки.

Да, иногда хаки и неправильные решения нужны в практике разработки, но как исключения, а не как правило.


** Интерактивность и наглядность, быстрая обратная связь
Тут нужно пояснить, что я имею в виду. Возьмём, например, программу на C:

#+begin_src c
  #include <stdio.h>
  #include <math.h>

  // Функция для ввода коэффициентов уравнения
  void inputCoefficients(double *a, double *b, double *c) {
      printf("Введите коэффициенты a, b и c: ");
      scanf("%lf %lf %lf", a, b, c);
  }

  // Функция для вычисления дискриминанта
  double calculateDiscriminant(double a, double b, double c) {
      return b * b - 4 * a * c;
  }

  // Функция для вычисления корней квадратного уравнения
  void calculateRoots(double a, double b, double c, double discriminant) {
      if (discriminant > 0) {
          double root1 = (-b + sqrt(discriminant)) / (2 * a);
          double root2 = (-b - sqrt(discriminant)) / (2 * a);
          printf("Два корня: %lf и %lf\n", root1, root2);
      } else if (discriminant == 0) {
          double root = -b / (2 * a);
          printf("Один корень: %lf\n", root);
      } else {
          printf("Корней нет\n");
      }
  }

  int main() {
      double a, b, c;
      inputCoefficients(&a, &b, &c);

      double discriminant = calculateDiscriminant(a, b, c);
      calculateRoots(a, b, c, discriminant);

      return 0;
  }
#+end_src

Смотрите, как тут всего много! И арифметические выражения, и ввод-вывод, и вызовы функций, и if else. Так хочется посмотреть всё это в отдельности! Вызвать функцию с разными параметрами отдельно от остальных. Но увы, это не так просто. Обычный порядок работы состоит в том, чтобы написать программу целиком, с вводом выводом, всем что нужно, и скомпилировать её, запустить, посмотреть результат. 

Чтобы посмотреть, что в отдельности делает каждая конструкция, нам нужен так называемый REPL - Read, Eval, Print Loop (Цикл чтения, выполнения, печати). Он принимает какое-то выражение, и исполняет его. Например, REPL может принять одно арифметическое выражение, исполнить его и вернуть получившееся число. Так же и с условными конструкциями и вызовами функций (хотя не во всех языках они относятся к выражениям). Может показаться, что это не нужно, но поверьте мне, это *очень* удобно и приятно. Когда мне после работы с REPL пришлось работать без него, я был сильно огорчён.

Преимущества у такого подхода следующие:
 1) Быстрая обратная связь. Можно очень быстро посмотреть, что делает одна конкретная функция, не дописывая программу целиком, и если что-то не так, сразу получить ошибку. Это очень важно, если у студента есть проблемы с вниманием. Полагаю, что таких всё больше и больше.
 2) Можно изучать определённые конструкции отдельно от всего остального языка.
 3) Если забыл, как работает та или иная функция, можно быстренько посмотреть, что и как она делает.
 4) Крайне упрощается отладка. Как известно, отладить программу гораздо труднее, чем написать с нуля. Чем больше мы упростим этот процесс, тем лучше.

Хочется отдельно сказать, что при таком подходе обработка данных отделяется от ввода и вывода. Ввод и вывод организуется самими REPL.

Очень трудно описать всё удобство работы с REPL, лучше всего самому поработать с ним, например, в языке Racket.

** Удобство написания тестов
В книге "How to design programs" (HtDP) приводится рецепт, стандартный способ того, как спроектировать функцию. Суть его примерно в следующем:
 1) Определить, что функция делает. Какую задачу она решает? Какие данные принимает?
 2) Определить её сигнатуру, описать назначение, написать заголовок.
 3) *Привести примеры использования функции*
 4) Написать макет
 5) Завершить написание функции
 6) *Протестировать её.*

Авторы предлагают оформлять примеры в тесты уже после написания функции, но мне больше по душе писать их до основного кода. Такая практика, при некоторых дополнениях называется разработкой через тестирование, и при правильном применении (при правильном!) приносит замечательные плоды.

Чем же хорош такой подход?
 1) Студент в первую очередь думает об интерфейсе функции, её назначении, а не о реализации. 
 2) Студент приучается писать тесты. Это архиважно в промышленных проектах. Без тестов поддерживать их - одно мучение.
 3) Студента радуют галочки на экране, которые свидетельствуют о том, что тесты прошли успешно.

Кроме того, это полезно и преподавателю. Давая задание, он может проверять его автоматически, запуская свои тесты.

** Простой инструментарий
Когда человек учится управлять самолётом, его не сажают за Боинг 747. Его сначала учат летать на симуляторе, а потом сажают за условную поршневую
Цесну, которой очень просто управлять. Современные профессиональные IDE похожи как раз на Боинг, а то и на Буран. В них очень много различных функций, которые и профессионалы не все знают.

Все эти кнопки, настройки и прочая машинерия только путают новичка. А если что-то пошло не так... Нужно звать преподавателя, чтобы он всё починил. 

Всё лишнее нужно убрать как можно дальше, чтобы не отвлекать внимание от самой сути. Должно быть минимум кнопок, максимум пользы. Суть процесса не должна скрываться от студента за кнопками.

В данном контексте, очень хорошим примером может послужить IDE DrRacket. Он простая, в ней есть REPL, отладчик, кнопок по минимуму. Сломать что-то очень трудно. Дизайн красивый и удобный. Очень рекомендую ознакомиться с этой средой, она замечательно иллюстрирует эту статью, как и сам язык Racket. Эта среда разработки даже позволяет вводить прямо в исходный код или REPL изображения!

** Понятные сообщения об ошибках
Это очень важно. Новичка могут пугать страшные английские слова, которые не говорят ему ничего кроме "ТЫ ПЛОХОЙ ПРОГРАММИСТ, НИЧЕГО НЕ УМЕЕШЬ"[fn:: Если он вообще их читает]. Сообщение об ошибке должно дать человеку максимум информации, в понятном ему виде, и как можно точнее указать место, где возникла ошибка. Чем меньше незнакомых концепций при этом задействовано, тем лучше.

Великим благом были бы сообщения, написанные на русском. Кроме того, желательно иметь справочник, в котором описаны все возможные ошибки.

Одни из лучших сообщений об ошибках предоставляет язык Rust.

** Подробная, понятная документация
Все данные о языке должны быть представлены в удобной и понятной документации. Чем она полнее, понятнее, чем больше в ней примеров, тем лучше. Желательно, чтобы система документации была тесно интегрирована с IDE, чтобы можно было очень быстро переходить к определению функции, к её документации и к её тестам. Очень удобно, если документация интегрирована с автодополнением, и при выборе функции, которую нужно ввести выводилось её описание (хотя не знаю, насколько это полезно новичкам). Это позволит не отвлекаться от программирование на поиск документации.

** Хорошая интеграция всех инструментов
Все эти инструменты, такие как IDE, документация, система сборки, менеджер пакетов и так далее должны быть хорошо интегрированы друг с другом. Так, например, систему сборки можно очень легко объединить с менеджером пакетов в одну программу, как это сделано, например в Rust. Если весь инструментарий хорошо интегрирован, пользоваться языком гораздо проще и приятнее.

* Особенности языка C++

Давайте же критически рассмотрим язык C++ в контексте этих критериев.

Для начала заметим, что C++ - это **промышленный** язык программирования, предназначенный для разработки крупных программных систем. Он очень мощный, и позволяет многое. Но вместе с тем, он очень сложный.

Определённо, нужно учить программистов C++, ведь на этом языке есть очень много легаси-кода, да и библиотек тоже. Но стоит ли использовать его для новых проектов, которые пишутся с нуля? Вопрос открытый. Возможно, стоит посмотреть на Rust (это действительно замечательный язык), и если есть доступные библиотеки, и программисты, имеет смысл использовать его. При этом, Rust противопоказано учить первым языком.

** Концептуальная стройность

C++ развивается уже **40 лет**, его основы были заложены в 70-х (в языке Си) и 80-х. Это огромный срок. За всё это время в языке накопилось очень большое количесво **привнесённой сложности**. Очень многие концепции языка плохо сочетаются между собой, используются не во всём языке, хотя могли бы, если бы их добавили изначально. Многие концепции, заложенные в ходе развития языка уже успели устареть.

Если какой-то программный продукт развивается столько времени, в его кодовой базе обязательно нужно проводить рефакторинг. Но с языком провести рефакторинг - значит попрощаться с обратной совместимостью, создать новый язык, как было с Python 3.

Кроме того, C++ - это высокоуровневый язык, с элементами низкоуровневого (в данном контексте C - низкоуровневый язык). В результате студент будет просто растянут между двумя этими уровнями. Может, и есть смысл в том, чтобы изучать их одновременно, но делать это в одном и том же языке мне кажется неразумным. Это увеличивает когнитивную сложность, приходится смешивать весьма непростые вещи, одновременно учиться строить абстракции и управлять памятью, следить за указателями. Конечно, работать с указателями нужно уметь. Но этому можно научиться и позже.

** Обозримость языка

Можно ли сказать, что C++ обозрим, или тем более, что его можно реализовать самому? Конечно нет! Стандарт занимает больше 1600 страниц. Даже професионалы могут не знать его целиком. При этом есть особенности реализации и неопределённое поведение.

** Постепенное увеличение сложности

Hello, World! на C++ выглядит так:

#+begin_src c++
  #include <iostream>

  using namespace std;

  int main()
  {
      cout << "Hello, world!" << endl;
      return 0;
  }
#+end_src

Сколько же концепций задействовано в этом примере? Считаем!

1.  #include <iostream> - Препроцессор - 1, Библиотеки - 2, Потоки - 3
2.  using namespace std; - Пространства имён - 4
3.  int main() - Объявление функции - 5, Типы данных - 6
4.  cout << "Hello, world!" << endl; - Потоки (уже сказал), Строки - 7, Операторы (ещё и с перегрузкой) - 8, Переменные - 9
5.  return 0; - Возврат значения из функции - 10 Код ошибки - 11

Я насчитал 11 концепций. И все они предлагаются людям, которые, может быть, вообще толком не программировали. Что же они усвоят? В худшем случае, что программирование - это волшебные заклинания, которые нужно зубрить и вводить не понимая. И нам ещё не приходилось работать с указателями и управлять памятью. Конечно, для профессионала это всё очень хорошо. Но мы говорим о новичках с очень различной мотивацией.

Очень высока вероятность, что большинство людей **не знакомых с программированием** вообще почти ничего не поймут и просто будут заниматься другими делами.

Для сравнения, вот, как Hello, World! выглядит на Racket:

#+begin_src racket
#lang racket            ; Выбираем, какой язык использовать. Эту строчку можно убрать, если выбрать язык в IDE
(print "Hello, World!") ; Вызов функции - 1, Строки - 2
#+end_src

** Хорошие практики программирования

C++ - это мультипарадигменный язык программирования. Основные парадигмы - процедурная и объектно-ориентированная. К сожалению, функциональный подход здесь не самый органичный.

Вызывает вопросы сама концепция ООП в C++. Некоторые современные языки уже отказались от такой системы. В Golang и Rust, например, нет наследования. И классов в таком же виде тоже нет. И это не спроста. Наследование, тем более множественное, может вызывать появление очень странных иерархий классов, которые потом трудно понимать. Это отдельная тема, по ней есть статьи.

Кроме того, в языке взможны хаки вроде while(*p++=*q++); Такие вещи ни в коем случае нельзя давать делать новичкам.

** Интерактивность и наглядность, быстрая обратная связь

От части я разбирал это, когда говорил об интерактивности. В C++ REPL не является обычной практикой. Есть Cling, но его использование - не стандартная практика.

Без REPL ученики лишаются тех огромных удобств, которые я расписал в предыдущей части статьи.

И конечно же, и речи быть не может идти о том, чтобы вставлять картинки в код программы, как в Racket.

** Удобство написания тестов

Как и в любом промышленном языке есть развитые фреймворки для написания тестов. Тут его нельзя ругать. Но проблема в том, что для того, чтобы использовать их, нужно уже знать язык на некотором уровне. А тесты могут очень помочь студентам на самых ранних этапах, буквально тогда, когда мы изучаем объявление функций, это говорит мой скромный опыт преподавания программирования.

Можно, конечно, писать тесты вручную, но тогда придётся писать очень много шаблонного кода, а это никому не понравится.

** Вопрос инструментария

Инструментарий у C++ очень обширный, мощный, но он не для новичков. Его нужно изучать отдельно, а с ним и множество других концепций. Это конечно же можно делать, но уже тогда, когда новички хорошо освоят базу. Иначе это будет смешивание в кучу сложных вещей, которое приведёт к повышению учебной нагрузки.

С документацией у C++ всё хорошо, есть много уроков курсов, где всё подробно объясняется. Но будут ли студенты, загруженные кучей предметов искать их и смотреть? У них очень много других дел, и очень много отвлекающих факторов. Понятно, что делать это будут не все.

Тут есть ещё вопрос, насколько всё это интегрировано между собой? Так, например, для Rust есть один пакетный менеджер, и он же система сборки - cargo. Он разрабатывается и поставляется вместе с компилятором rustc, его используют почти все (хотя, скорее все, без "почти") Rust программисты. Есть стандартный генератор документации, стандартный языковой сервер, который отвечает за автодополнение и прочие подсказки в IDE. Всё это очень тесно интегрировано.

Язык C++ определяется стандартом, который каждый может реализовать сам. В результате инструментарий так же разрабатывается разными людьми. Хотя, конечно, CMake и Clang - это замечательные инструменты, очень распространённые и поддерживаемые.

** Итоги критики

Подводя итог всей этой критики, я хочу сказать, что каким бы мощным и востребованным языком ни был C++, его не стоит преподавать новичкам, которые не изучали программирование раньше. Изучение этого языка стоило бы **отложить** где-то на второй курс, когда студенты уже будут хорошо справляться с построением абстракций, разделением программы на части, научатся думать как программисты. Возможно, стоит отложить этот язык ещё дальше, и для начала изучить простой и гораздо более понятный C. 

Возможно, стоило бы дать студентам выбор между C++ и Rust, так как этот язык очень бурно развивается, гораздо более согласован и вообще, он более современный.

** Альтернатива C++ на первом курсе

Как, возможно, вы уже поняли, достойной альтернативой для обучения новичков программированию мне представляется язык Racket. Но не в нём дело. Дело в том, что для обучения программированию нужно использовать специально предназначенный для этого язык программирования, такой как Pascal, Racket или Pyret. Они позволят новичкам легко и без привнесённой сложности изучить программирование. Racket здесь хорош наличием REPL.

К сожалению, и у Racket есть свои недостатки. Так, основные материалы по нему на английском. Сам Racket не создан с нуля, а основан на языке Scheme, и наследует некоторые его недостатки. IDE DrRacket тоже не идеальна. В ней не до конца интегрирована система документации. Плохо сделана подсветка синтаксиса.

Если мы най

Думаю, хорошая идея - создать свой учебный язык с нуля. Это даст следующие преимущества:

1.  Вся документация будет создаваться русскими людьми для русских людей.
2.  Можно обеспечить высочайшую степень интеграции инструментария.
3.  Будет получен бесценный опыт проектирования языков программирования.

* Проблемы специального языка
При всех преимуществах, специализированный учебный язык имеет и ряд недостатков.

** Нет учебных программ и материалов
Что ни говори, а программы, использующие C++ очень тесно интегрированы в образовательную систему. Переписать их может быть очень и очень сложно.

Чуть проще создать образовательные материалы.

** Практика
Для того, чтобы научиться программировать, нужно очень много программировать. И очень много читать чужого кода. К сожалению, на специальных языках написано не так много библиотек и программ. Больше всего кода на Pascal и Racket. Эту проблема может быть решена тем, что новички будут писать дополнительные функции для библиотек языка в качестве курсовых работ. Проектированием этих библиотек, должны заниматься, конечно, профессионалы.

Второй момент - студенты не смогут сразу пойти работать. Их просто никто не возьмёт. Хотя это не так страшно. Совсем новичок-программист должен твёрдо освоить базу, а потом уже идти в бой. С другой стороны, так ли долго будет идти курс по учебному языку? Может быть, это будет только первый курс?

** Отвращение к промышленным языкам
Как ни странно, изучение простого, приятного языка может настроить студентов против того же C++. Им будет очень не хватать REPL и интегрированности инструментария. Лично со мной так и произошло.
